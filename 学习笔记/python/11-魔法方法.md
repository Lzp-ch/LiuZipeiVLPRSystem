# 魔法方法

魔法方法总是被双下划线包围`__init__`

魔法方法是面向对象的python的一切，很强大，强大之处在于它总能在合适的时候自动的被调用

## 构造和析构

### `__init__`

初始化的时候出发

### `__new__`

创建类实例的时候触发

### `__del__(self)`

垃圾回收机制回收垃圾时调用。当一个对象真正成为垃圾的时候才会调用（所有引用都被删除，没有人用这个对象了）

~~~python
class C:
	def __del__(self):
		print('__del__方法被调用')

c1 = C() #实例化对象c1
c2 = c1  #创建一个对c1的引用
c3 = c1  #创建一个对c1的引用
del c3  #无事发生
del c1  #无事发生
del c2  #输出：__del__方法被调用
#不管先删除谁，全部删掉以后才会垃圾回收
~~~



## 算数运算

在python中其实所有东西都是对象，比如1+1也是调用了int中的add方法，所以其实可以重写各种算数方法

比如，重新定义New_int对象中的加减法

~~~Python
class New_int(int):
    def __add__(self, other):
        return int.__sub__(self, other)
    def __sub__(self, other):
        return int.__add__(self, other)

a = New_int(3)
b = New_int(5)
a + b
#输出-2
a - b
#输出8
~~~

### 反运算

如果两个对象相加`a+b`，a没有`add()`方法，那么python会去找b的`__radd()__`方法进行运算

要注意参数self位置，这决定了谁加谁

## 属性访问

`__getattribute__`当属性被访问时触发，先于getattr

`__getattr__`当请求访问的属性不存在时触发

`__setattr__`设置属性时触发

`__delattr__`删除属性时触发

~~~PYTHON
class C:
    def __getattribute__(self, name):
        print('getattribute')
        return super().__getattribute__(name)
    def __getattr__(self, name):
        print('getattr')
    def __setattr__(self, name, value):
        print('setattr')
        super().__setattr__(name, value)
    def __delattr__(self, name):
        print('delattr')
        super().__delattr__(name)

c = C()
c.x
#getattribute 最先
#getattr
c.x = 1
#setattr
c.x
#getattribute 他找到了属性，getattr就不触发了
#1
>>> 
~~~

